<!doctype html><html lang=en><head><title>Heaps Don't Lie; They Save Lives ::
masoudkf — Developer Blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" If you&rsquo;re not familiar with (binary) heaps, they&rsquo;re a tree-like data structure backed by arrays (or slices in Go). I&rsquo;ve seen in some places where they call heaps tree-based data structures, and I don&rsquo;t think that&rsquo;s accurate. You&rsquo;ll see pretty soon that heaps are basically lists, but the way they hold and arrange items in that list makes them look a lot like trees. You can use trees to describe them, and you can use trees to show all their operations; but at the end of the day, they&rsquo;re just lists, albeit a special one.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://masoudkarimif.github.io/posts/heaps-dont-lie/><link rel=stylesheet href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet><link rel=stylesheet href=https://masoudkarimif.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://masoudkarimif.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://masoudkarimif.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Heaps Don't Lie; They Save Lives"><meta name=twitter:description content="Go's `container` package helps you create heaps, although not as easy as other languages like Python do. But that makes it more fun."><meta property="og:url" content="https://masoudkarimif.github.io/posts/heaps-dont-lie/"><meta property="og:site_name" content="masoudkf"><meta property="og:title" content="Heaps Don't Lie; They Save Lives"><meta property="og:description" content="Go's `container` package helps you create heaps, although not as easy as other languages like Python do. But that makes it more fun."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-07T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Heaps"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Algorithms"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZFRSZRJSCV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZFRSZRJSCV")}</script></head><body class=light-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>masoudkf</span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/reads>Reads</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/reads>Reads</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>Heaps Don&rsquo;t Lie; They Save Lives</h1><div class=post-meta><time class=post-date>2024-10-07
</time><span class=post-author>— by masoudkf</span>
<span class=post-read-time>— 7 min read</span></div><span class=post-tags><a href=https://masoudkarimif.github.io/tags/go/>#go</a>&nbsp;
<a href=https://masoudkarimif.github.io/tags/heaps/>#heaps</a>&nbsp;
<a href=https://masoudkarimif.github.io/tags/performance/>#performance</a>&nbsp;
<a href=https://masoudkarimif.github.io/tags/algorithms/>#algorithms</a>&nbsp;</span><div class=post-content><br><p align=center><img src=https://res.cloudinary.com/mkf/image/upload/v1728266804/Gemini_Generated_Image_ls11eols11eols11_vtfsp9.jpg width=500></p><br><p>If you&rsquo;re not familiar with (binary) heaps, they&rsquo;re a tree-<strong>like</strong> data structure backed by arrays (or slices in Go). I&rsquo;ve seen in some places where they call heaps tree-<strong>based</strong> data structures, and I don&rsquo;t think that&rsquo;s accurate. You&rsquo;ll see pretty soon that heaps are basically lists, but the way they hold and arrange items in that list makes them look a lot like trees. You can use trees to describe them, and you can use trees to show all their operations; but at the end of the day, they&rsquo;re just lists, albeit a special one.</p><p>Because they act like trees, they can perform operations (like inserts and removes) in <code>O(logN)</code> where <code>N</code> is the size of the heap (or list). You may also see <code>O(h)</code> where <code>h</code> is the height of the tree. And because heaps can be shown as a near-complete binary tree, they&rsquo;re balanced and hence their height is <code>O(logN)</code> where <code>N</code> is the number of nodes. So, basically saying the same thing with a different notation.</p><h3 id=who-cares>Who Cares?
<a href=#who-cares class=h-anchor aria-hidden=true>#</a></h3><p>You may be a software engineer and never have come across heaps in your career, and that&rsquo;s totally fine. It&rsquo;s not like heaps are used in everyday solutions. However, there are some situations where you may like to consider heaps. Situations where, at any time, you&rsquo;re only interested in finding the next maximum or minimum in a list of things. You don&rsquo;t care about the rest of the things, you only care what the maximum or minimum thing is at this very moment. And that thing could be anything. Could be a simple number, or a more complex structure, like an object, or <code>struct</code> in Go.</p><p>For example, let&rsquo;s say you&rsquo;re implementing a shortest-path algorithm (like the Dijkstra&rsquo;s algorithm). Chances are, at each iteration, you want to get the next smallest path (or edge) to process. Heaps to the rescue! A min-heap can help you out here. It specializes in giving you the next minimum in <code>O(logN)</code> time. Fun fact: a very popular implementation of the Dijkstra&rsquo;s algorithm uses a min-heap.</p><p>Or say you want to build some software to be used in emergency rooms. Patients come at different times and each has a priority assigned to them based on how critical their situation is. e.g. priority 5 being the highest and most critical situation and priority 1 being the least urgent one. What&rsquo;s important here is to get the next patient in the highest critical situation and assign them to a doctor. Enter max-heaps! A max-heap can help you get the next highest priority patient in <code>O(logN)</code> time.</p><p>The examples are abound. Another example is task scheduling, or even leaderboards.</p><p>If instead of a heap, you use a simple slice (or list), each time you&rsquo;re looking for the next maximum or minimum, you&rsquo;d need to spend <code>O(N)</code> time to find it; so, using heaps could help you achieve better performance.</p><h2 id=heaps-in-go>Heaps in Go
<a href=#heaps-in-go class=h-anchor aria-hidden=true>#</a></h2><p>Unlike Python, where you can start with a <a href=https://docs.python.org/3/library/heapq.html>heap</a> pretty quick, Go asks you to do a bit more before having a functional heap. The <code>container</code> package comes with a <a href=https://pkg.go.dev/container/heap@go1.23.2><code>heap</code></a> package to get you started, but you need to do some of the leg-work.</p><h3 id=heap-interface>Heap Interface
<a href=#heap-interface class=h-anchor aria-hidden=true>#</a></h3><p>Go lets you turn any slice of primitive or custom type into a heap if you implement the <a href=https://pkg.go.dev/container/heap@go1.23.2#Interface>heap interface</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>Interface</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>any</span>) <span style=color:#75715e>// add x as element Len()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Pop</span>() <span style=color:#a6e22e>any</span>   <span style=color:#75715e>// remove and return element Len() - 1.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>As you see, the <a href=https://pkg.go.dev/sort#Interface><code>sort.Interface</code></a> is also embedded, which means you need to satisfy that as well:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Interface</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So, basically, you implement these 5 functions and you got yourself a heap. Let&rsquo;s build one.</p><h3 id=emergency-room-heap>Emergency Room Heap
<a href=#emergency-room-heap class=h-anchor aria-hidden=true>#</a></h3><p>Let&rsquo;s build a heap that an emergency room can use. Patients are described by the following struct:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Patient</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>index</span>    <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>priority</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Where higher priority means more critical. So, in other words, we need a max-heap.</p><p>Remember my discussion at the beginning that heaps are basically slices (some say <strong>backed</strong> by slices), so we need a slice of <code>Patient</code>s. Here it is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>PatientHeap</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>Patient</span>
</span></span></code></pre></div><p>I declared it as a new type so I can add method on it to satisfy the interface.</p><h4 id=implementing-the-heap-interface>Implementing the Heap Interface
<a href=#implementing-the-heap-interface class=h-anchor aria-hidden=true>#</a></h4><p>Let&rsquo;s implement the interface. Remember that we need to implement 5 functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Len returns the size of the heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ph</span> <span style=color:#a6e22e>PatientHeap</span>) <span style=color:#a6e22e>Len</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>ph</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Swap swaps item i with item j in the heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ph</span> <span style=color:#a6e22e>PatientHeap</span>) <span style=color:#a6e22e>Swap</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>j</span>] = <span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>j</span>], <span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>j</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Less returns true if item i is bigger that item j.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This is how we build a max-heap. To build a min-heap replace &gt; with &lt;.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ph</span> <span style=color:#a6e22e>PatientHeap</span>) <span style=color:#a6e22e>Less</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>priority</span> &gt; <span style=color:#a6e22e>ph</span>[<span style=color:#a6e22e>j</span>].<span style=color:#a6e22e>priority</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Push adds an item to the heap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It simply appends a new item to the slice.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Needs to be pointer receiver because it 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// changes the size of the slice.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ph</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PatientHeap</span>) <span style=color:#a6e22e>Push</span>(<span style=color:#a6e22e>x</span> <span style=color:#a6e22e>any</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>Patient</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>index</span> = len(<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span> = append(<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>, <span style=color:#a6e22e>item</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pop returns and removes the minimum.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Needs to be pointer receiver because it 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// changes the size of the slice.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>ph</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>PatientHeap</span>) <span style=color:#a6e22e>Pop</span>() <span style=color:#a6e22e>any</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> len(<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>)[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>index</span> = <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	(<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>)[<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>ph</span>)[<span style=color:#ae81ff>0</span> : <span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>item</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Less</code>, <code>Len</code>, and <code>Swap</code> functions are very straightforward. The only gotcha is the <code>Less</code> function. If you want a max-heap, you do it like the example above; if you want a min-heap, you need to use a <code>&lt;</code> operator instead.</p><p>The last two functions, <code>Push</code> and <code>Pop</code>, use a pointer receiver because they resize the underlying slice, so watch out for that. The <code>Push</code> function simply appends a new item to the slice, however, the <code>Pop</code> function is more complicated.</p><p>At the first sight, you can see it removes and returns the <strong>last</strong> item of the slice (it also assigns <code>nil</code> to the last pointer so GC can pick it up). The part that confused me at the beginning, though, was why do we remove the <strong>last</strong> item and not first one?</p><p>If you read any article on heaps, you&rsquo;ll see that the item you want to pop, whether it&rsquo;s the min or max, is always at the root of the tree, or first item of the list. Even the Go docs confirms this:</p><blockquote><p>The minimum element in the tree is the root, at index 0.</p></blockquote><p>But if you try to remove and return the first item, it won&rsquo;t work. It will compile, but you&rsquo;ll get wrong results!</p><p>So, I had to look at the source code <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.23.2:src/container/heap/heap.go;l=59">here</a> to find what was going on behind the scene. Here&rsquo;s the code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Pop</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>Interface</span>) <span style=color:#a6e22e>any</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>Len</span>() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>Swap</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>down</span>(<span style=color:#a6e22e>h</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>Pop</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You see that before calling <code>Pop</code> on the heap, the code swaps the root (item at index <code>0</code>) with the last item (item at index <code>h.Len() - 1</code>). In other words, before <strong>our</strong> <code>Pop</code> function is called, the root, which the item we want to remove and return, is moved to the <strong>end</strong> of the slice. So, be careful about that. (If you&rsquo;re wondering what <code>down</code> does, you can take a look at the source code. But in a nutshell, it heapifies the heap, meaning it makes sure the heap is organized properly now that the root is gone)</p><h4 id=using-the-heap>Using the Heap
<a href=#using-the-heap class=h-anchor aria-hidden=true>#</a></h4><p>Now that we have implemented the heap interface, let&rsquo;s use it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Make the heap slice
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ph</span> <span style=color:#f92672>:=</span> make(<span style=color:#a6e22e>PatientHeap</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initialize the heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Init</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ph</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>100</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Push items into the heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Push</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ph</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Patient</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>priority</span>: <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#ae81ff>10</span>),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>index</span>: <span style=color:#a6e22e>i</span>,
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>ph</span>.<span style=color:#a6e22e>Len</span>() &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Pop items from the heap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>heap</span>.<span style=color:#a6e22e>Pop</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ph</span>).(<span style=color:#f92672>*</span><span style=color:#a6e22e>Patient</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>priority</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You start by making a slice to back the heap, then initialize the heap using <code>heap.Init()</code> and then you can <code>Push</code> and <code>Pop</code> to and from the heap. Just remember to use the methods through the <code>heap</code> package, so <code>heap.Push()</code> and <code>heap.Pop()</code>.</p><p>See the full code below:</p><script src=https://gist.github.com/masoudkarimif/2a5aee8455ace38f5c78b834a1d425ed.js></script><br><p>And there it is. Our beautiful heap, which will save lives at any emergency room. A life-saving heap, if you will.</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://masoudkarimif.github.io/posts/whos-in-the-shahnameh/><span class=button__icon>←</span>
<span class=button__text>Who's in the Shahnameh? Tries Can Help.</span>
</a></span><span class="button next"><a href=https://masoudkarimif.github.io/posts/benchmarking-go-sort-functions/><span class=button__text>Benchmarking Go Sort Functions</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>masoudkf</span></a><div class=copyright><span>© 2024 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZFRSZRJSCV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZFRSZRJSCV")}</script></body></html>