<!doctype html><html lang=en><head><title>Who's in the Shahnameh? Tries Can Help. ::
masoudkf — Blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In case you&amp;rsquo;re not familiar with the Shahnameh, it&amp;rsquo;s a book about Persian kings (Shahnameh means Book of Kings). It&amp;rsquo;s a masterpiece written by the Persian poet Ferdowsi. There are many stories in the book, and of course, so many characters. Read more on Wikipedia.
We want to create an application (in Go, of course) that gives us autocompletion when we&amp;rsquo;re searching for a character name. For instance, when I start typing ma, it gives me Manijeh, Manuchehr, and Mardas."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://masoudkarimif.github.io/posts/whos-in-the-shahnameh/><link rel=stylesheet href=/css/style.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet><link rel=stylesheet href=https://masoudkarimif.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://masoudkarimif.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://masoudkarimif.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Who's in the Shahnameh? Tries Can Help."><meta name=twitter:description content="Tries are tree-like data structures used in applications such as autocomplete and spell checkers. For example, is there a character in the Shahnameh whose name starts with a Z? Well, let's see."><meta property="og:url" content="https://masoudkarimif.github.io/posts/whos-in-the-shahnameh/"><meta property="og:site_name" content="masoudkf"><meta property="og:title" content="Who's in the Shahnameh? Tries Can Help."><meta property="og:description" content="Tries are tree-like data structures used in applications such as autocomplete and spell checkers. For example, is there a character in the Shahnameh whose name starts with a Z? Well, let's see."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-13T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Tries"><meta property="article:tag" content="Algorithms"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZFRSZRJSCV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZFRSZRJSCV")}</script></head><body class=light-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>masoudkf</span>
</a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/reads>Reads</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/reads>Reads</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>Who&rsquo;s in the Shahnameh? Tries Can Help.</h1><div class=post-meta><time class=post-date>2024-10-13
</time><span class=post-author>— by masoudkf</span>
<span class=post-read-time>— 6 min read</span></div><span class=post-tags><a href=https://masoudkarimif.github.io/tags/go/>#go</a>&nbsp;
<a href=https://masoudkarimif.github.io/tags/tries/>#tries</a>&nbsp;
<a href=https://masoudkarimif.github.io/tags/algorithms/>#algorithms</a>&nbsp;</span><div class=post-content><br><p align=center><img src=https://res.cloudinary.com/mkf/image/upload/v1728863652/shahnameh_mkbmzm.png width=600></p><br><p>In case you&rsquo;re not familiar with the Shahnameh, it&rsquo;s a book about Persian kings (Shahnameh means Book of Kings). It&rsquo;s a masterpiece written by the Persian poet Ferdowsi. There are many stories in the book, and of course, so many characters. Read more on <a href=https://en.wikipedia.org/wiki/Shahnameh>Wikipedia</a>.</p><p>We want to create an application (in Go, of course) that gives us autocompletion when we&rsquo;re searching for a character name. For instance, when I start typing <code>ma</code>, it gives me <code>Manijeh</code>, <code>Manuchehr</code>, and <code>Mardas</code>. How? Tries to the rescue.</p><h2 id=tries>Tries
<a href=#tries class=h-anchor aria-hidden=true>#</a></h2><p>Tries are tree-like data structures used in applications such as autocomplete and spell checkers. They have a root, which doesn&rsquo;t hold any information, other than it&rsquo;s where you begin traversing the tree, and a number of nodes where each node contains a character from your dictionary. Read more on <a href=https://en.wikipedia.org/wiki/Trie>Wikipedia</a>.</p><h3 id=node-relations>Node Relations
<a href=#node-relations class=h-anchor aria-hidden=true>#</a></h3><p>A parent-child relationship in a trie represents two consecutive characters where the parent comes before the child. For instance, if the parent node has the character <code>i</code> and the child node represents a <code>d</code>, then together they create <code>id</code>.</p><br><p align=center><img src=https://res.cloudinary.com/mkf/image/upload/v1728860389/Untitled_Diagram.drawio_osyqmm.png width=300></p><p style=text-align:center><i>A Trie</i></p><br><p>Look at the trie above. It has 4 different words in it: <code>masoud</code>, <code>master</code>, <code>lake</code>, and <code>late</code>. As you can see, words can share prefixes, and that makes tries efficient for prefix lookups. Given a prefix, it can find all the words that share that prefix in linear time <code>O(N)</code> where <code>N</code> is the length of the longest word found, whereas a data structure like a list, or even a hash map, can solve the problem in <code>O(N)</code> where <code>N</code> is the size of the dictionary. So, big difference. Also, in terms of memory, tries are more efficient as they don&rsquo;t store the same prefix twice.</p><p>Aside from the character that each node holds, it also contains a flag to show if it&rsquo;s the end character or not. For example, in the trie above, characters <code>d</code>, <code>r</code>, <code>e</code>, and <code>e</code> (different <code>e</code>) are end characters. It&rsquo;s important to have this property on the nodes to distinguish between words and a sequence of characters.</p><h3 id=child-nodes>Child Nodes
<a href=#child-nodes class=h-anchor aria-hidden=true>#</a></h3><p>As shown in the above figure, each child node holds a character from the dictionary, so it&rsquo;s important to know your characters. Usually, you create a hash map for this.</p><h2 id=go-implementation>Go Implementation
<a href=#go-implementation class=h-anchor aria-hidden=true>#</a></h2><p>We start by declaring the tree and its nodes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// trieNode represents a node in a trie.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>trieNode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>children</span> []<span style=color:#f92672>*</span><span style=color:#a6e22e>trieNode</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// the character this nodes represents.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>char</span>     <span style=color:#66d9ef>rune</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// is this the end character of a word.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>isEnd</span>    <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// trie represents a trie data structure.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>trie</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>trieNode</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// NewTrie creates a new trie data structure.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewTrie</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>trie</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>trie</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>root</span>: <span style=color:#a6e22e>NewTrieNode</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// NewTrieNode create a new trie node given a character.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewTrieNode</span>(<span style=color:#a6e22e>char</span> <span style=color:#66d9ef>rune</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>trieNode</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>trieNode</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>char</span>:     <span style=color:#a6e22e>char</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>children</span>: make([]<span style=color:#f92672>*</span><span style=color:#a6e22e>trieNode</span>, len(<span style=color:#a6e22e>alphabetMap</span>)),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Nothing really special here. Just a tree that has a root, and a bunch of nodes where each node can have a list of children. The last two are initializers to create a new trie and new nodes.</p><h3 id=dictionary-characters>Dictionary Characters
<a href=#dictionary-characters class=h-anchor aria-hidden=true>#</a></h3><p>As mentioned above, you need to know your characters and how many there are. Otherwise, you can&rsquo;t achieve linear lookups. In this step, you need to make sure you can see if a character exists as a child of a parent node in constant time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>alphabetMap</span> = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>rune</span>]<span style=color:#66d9ef>int</span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;a&#39;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;b&#39;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;c&#39;</span>: <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;d&#39;</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;e&#39;</span>: <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;f&#39;</span>: <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;g&#39;</span>: <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;h&#39;</span>: <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;i&#39;</span>: <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;j&#39;</span>: <span style=color:#ae81ff>9</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;k&#39;</span>: <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;l&#39;</span>: <span style=color:#ae81ff>11</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;m&#39;</span>: <span style=color:#ae81ff>12</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;n&#39;</span>: <span style=color:#ae81ff>13</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;o&#39;</span>: <span style=color:#ae81ff>14</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;p&#39;</span>: <span style=color:#ae81ff>15</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;q&#39;</span>: <span style=color:#ae81ff>16</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;r&#39;</span>: <span style=color:#ae81ff>17</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;s&#39;</span>: <span style=color:#ae81ff>18</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;t&#39;</span>: <span style=color:#ae81ff>19</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;u&#39;</span>: <span style=color:#ae81ff>20</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;v&#39;</span>: <span style=color:#ae81ff>21</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;w&#39;</span>: <span style=color:#ae81ff>22</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;x&#39;</span>: <span style=color:#ae81ff>23</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;y&#39;</span>: <span style=color:#ae81ff>24</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#39;z&#39;</span>: <span style=color:#ae81ff>25</span>,
</span></span><span style=display:flex><span>	<span style=color:#75715e>// adding space because some of Shahnameh characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// have space in their names. e.g. Kai Khosrow.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#e6db74>&#39; &#39;</span>: <span style=color:#ae81ff>26</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=populating-the-trie>Populating the Trie
<a href=#populating-the-trie class=h-anchor aria-hidden=true>#</a></h3><p>Before using a trie, it needs to include your dictionary of words. So, you need an insert method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Insert adds a word to the trie, provided all its
</span></span></span><span style=display:flex><span><span style=color:#75715e>// characters are supported.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>trie</span>) <span style=color:#a6e22e>Insert</span>(<span style=color:#a6e22e>word</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>word</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>word</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>current</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>char</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>word</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// checking if the character exists in constant time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>charIndex</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alphabetMap</span>[<span style=color:#a6e22e>char</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;character not supported&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// getting the character index (if exists) in constant time.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>charIndex</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>current</span> = <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>charIndex</span>] = <span style=color:#a6e22e>NewTrieNode</span>(<span style=color:#a6e22e>char</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>current</span> = <span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>charIndex</span>]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// the current node holds the end character of the word.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>isEnd</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We start from the <code>root</code> (almost always), and traverse the tree to see if we need to create a new node for a character. As long as the prefix already exists, we move to the next character by updating <code>current</code>. Once we find that this is a new prefix, we create a new trie node.</p><h3 id=autocomplete>Autocomplete
<a href=#autocomplete class=h-anchor aria-hidden=true>#</a></h3><p>Autocomplete is finding all the words that share the same prefix. So, given a prefix, or query, we want to find those words in the trie.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Autocomplete returns all the words that share the prefix `query`.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>trie</span>) <span style=color:#a6e22e>Autocomplete</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>suggestions</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>string</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>query</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ToLower</span>(<span style=color:#a6e22e>query</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>current</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>char</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>query</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>charIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>alphabetMap</span>[<span style=color:#a6e22e>char</span>]
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>children</span>[<span style=color:#a6e22e>charIndex</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>suggestions</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>current</span> = <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>findSuggestions</span>(<span style=color:#a6e22e>query</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// findSuggestions finds all the words that share the prefix `query`,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// starting from the trieNode it&#39;s called on.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>tn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>trieNode</span>) <span style=color:#a6e22e>findSuggestions</span>(<span style=color:#a6e22e>query</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>suggestions</span> []<span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tn</span>.<span style=color:#a6e22e>isEnd</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>suggestions</span> = append(<span style=color:#a6e22e>suggestions</span>, <span style=color:#a6e22e>query</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>childNode</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tn</span>.<span style=color:#a6e22e>children</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>childNode</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>suggestions</span> = append(<span style=color:#a6e22e>suggestions</span>, <span style=color:#a6e22e>childNode</span>.<span style=color:#a6e22e>findSuggestions</span>(<span style=color:#a6e22e>query</span><span style=color:#f92672>+</span>string(<span style=color:#a6e22e>childNode</span>.<span style=color:#a6e22e>char</span>))<span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>suggestions</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Autocomplete</code> method takes a prefix and first finds the node at the <strong>end</strong> of the prefix. For example, if the prefix is <code>la</code>, we first need to find <code>l</code>, and then <code>a</code>, and then find all the words that share this prefix.</p><p>Once the node that holds the last character of the prefix is found, the <code>findSuggestions</code> method is called on the node. It uses depth-first search (DFS) to find all the words with the same prefix. (recursion anyone?). And that&rsquo;s all there&rsquo;s to it.</p><p>There are other methods you can define on the Trie, such as find, or spellcheck, which is basically the same thing.</p><h2 id=demo>Demo
<a href=#demo class=h-anchor aria-hidden=true>#</a></h2><p>For the demo, I needed the character names from the Shahnameh to create my dictionary. I found a page on Wikipedia and turned the list into a Go slice. You can find the gist <a href=https://gist.github.com/masoudkarimif/1c7ba515aa0c67ba1f82c63f1f9bfa1a>here</a>.</p><p>After that, it was populating the trie and hooking it up to a front-end. See the demo <a href=https://shahnameh-names.masoudkf.com/>here</a>, and read the book too if you get a chance. It&rsquo;s fascinating!</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://masoudkarimif.github.io/posts/my-favorite-reads-of-2024/><span class=button__icon>←</span>
<span class=button__text>My Favorite Reads of 2024</span>
</a></span><span class="button next"><a href=https://masoudkarimif.github.io/posts/heaps-dont-lie/><span class=button__text>Heaps Don't Lie; They Save Lives</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>masoudkf</span></a><div class=copyright><span>© 2025 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZFRSZRJSCV"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZFRSZRJSCV")}</script></body></html>